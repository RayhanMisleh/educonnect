"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[153],{3999:(e,n,i)=>{i.d(n,{cn:()=>o});var t=i(2596),a=i(9688);function o(){for(var e=arguments.length,n=Array(e),i=0;i<e;i++)n[i]=arguments[i];return(0,a.QP)((0,t.$)(n))}},4720:(e,n,i)=>{i.d(n,{GL:()=>h});var t=i(5155),a=i(5538),o=i(7558),s=i(3264),r=i(2115),l=i(1991),u=i(2230);let c="\n  // Periodic noise function using sine and cosine waves\n  float periodicNoise(vec3 p, float time) {\n    // Create multiple frequency components for more complex movement\n    // All time multipliers are integer values to ensure perfect 2π periodicity\n    float noise = 0.0;\n    \n    // Primary wave - period = 2π\n    noise += sin(p.x * 2.0 + time) * cos(p.z * 1.5 + time);\n    \n    // Secondary wave - period = π (time * 2)\n    noise += sin(p.x * 3.2 + time * 2.0) * cos(p.z * 2.1 + time) * 0.6;\n    \n    // Tertiary wave - period = 2π/3 (time * 3)\n    noise += sin(p.x * 1.7 + time) * cos(p.z * 2.8 + time * 3.0) * 0.4;\n    \n    // Cross-frequency interaction - period = π (time * 2)\n    noise += sin(p.x * p.z * 0.5 + time * 2.0) * 0.3;\n    \n    return noise * 0.3; // Scale down the result\n  }\n";class v extends s.BKk{constructor(){super({vertexShader:"\n      uniform sampler2D positions;\n      uniform sampler2D initialPositions;\n      uniform float uTime;\n      uniform float uFocus;\n      uniform float uFov;\n      uniform float uBlur;\n      uniform float uPointSize;\n      varying float vDistance;\n      varying float vPosY;\n      varying vec3 vWorldPosition;\n      varying vec3 vInitialPosition;\n      void main() { \n        vec3 pos = texture2D(positions, position.xy).xyz;\n        vec3 initialPos = texture2D(initialPositions, position.xy).xyz;\n        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n        gl_Position = projectionMatrix * mvPosition;\n        vDistance = abs(uFocus - -mvPosition.z);\n        vPosY = pos.y;\n        vWorldPosition = pos;\n        vInitialPosition = initialPos;\n        gl_PointSize = max(vDistance * uBlur * uPointSize, 3.0);\n      }",fragmentShader:"\n      uniform float uOpacity;\n      uniform float uRevealFactor;\n      uniform float uRevealProgress;\n      uniform float uTime;\n      varying float vDistance;\n      varying float vPosY;\n      varying vec3 vWorldPosition;\n      varying vec3 vInitialPosition;\n      uniform float uTransition;\n\n      ".concat(c,"\n\n      // Sparkle noise function for subtle brightness variations\n      float sparkleNoise(vec3 seed, float time) {\n        // Use initial position as seed for consistent per-particle variation\n        float hash = sin(seed.x * 127.1 + seed.y * 311.7 + seed.z * 74.7) * 43758.5453;\n        hash = fract(hash);\n        \n        // Slow time variation (time / 10) for gentle sparkle effect\n        float slowTime = time * 1.0;\n        \n        // Create sparkle pattern using multiple sine waves with the hash as phase offset\n        float sparkle = 0.0;\n        sparkle += sin(slowTime + hash * 6.28318) * 0.5;\n        sparkle += sin(slowTime * 1.7 + hash * 12.56636) * 0.3;\n        sparkle += sin(slowTime * 0.8 + hash * 18.84954) * 0.2;\n        \n        // Create a different noise pattern to reduce sparkle frequency\n        // Using different hash for uncorrelated pattern\n        float hash2 = sin(seed.x * 113.5 + seed.y * 271.9 + seed.z * 97.3) * 37849.3241;\n        hash2 = fract(hash2);\n        \n        // Static spatial mask to create sparse sparkles (no time dependency)\n        float sparkleMask = sin(hash2 * 6.28318) * 0.7;\n        sparkleMask += sin(hash2 * 12.56636) * 0.3;\n        \n        // Only allow sparkles when mask is positive (reduces frequency by ~70%)\n        if (sparkleMask < 0.3) {\n          sparkle *= 0.05; // Heavily dampen sparkle when mask is low\n        }\n        \n        // Map sparkle to brightness with smooth exponential emphasis on high peaks only\n        float normalizedSparkle = (sparkle + 1.0) * 0.5; // Convert [-1,1] to [0,1]\n        \n        // Create smooth curve: linear for low values, exponential for high values\n        // Using pow(x, n) where n > 1 creates a curve that's nearly linear at low end, exponential at high end\n        float smoothCurve = pow(normalizedSparkle, 4.0); // High exponent = dramatic high-end emphasis\n        \n        // Blend between linear (for low values) and exponential (for high values)\n        float blendFactor = normalizedSparkle * normalizedSparkle; // Smooth transition weight\n        float finalBrightness = mix(normalizedSparkle, smoothCurve, blendFactor);\n        \n        // Map to brightness range [0.7, 2.0] - conservative range with exponential peaks\n        return 0.7 + finalBrightness * 1.3;\n      }\n\n      float sdCircle(vec2 p, float r) {\n        return length(p) - r;\n      }\n\n      void main() {\n        vec2 cxy = 2.0 * gl_PointCoord - 1.0;\n\n        // Define triangle vertices (equilateral triangle)\n        vec2 p0 = vec2(0.0, -0.8);     // top tip (flipped Y)\n        vec2 p1 = vec2(-0.7, 0.4);     // bottom left (flipped Y)\n        vec2 p2 = vec2(0.7, 0.4);      // bottom right (flipped Y)\n        \n        float sdf = sdCircle(cxy, 0.5);\n        \n        if (sdf > 0.0) discard;\n\n        // Calculate distance from center for reveal effect\n        float distanceFromCenter = length(vWorldPosition.xz);\n        \n        // Add noise to the reveal threshold for organic edge\n        float noiseValue = periodicNoise(vInitialPosition * 4.0, 0.0);\n        float revealThreshold = uRevealFactor + noiseValue * 0.3;\n        \n        // Create reveal mask based on distance from center (inverted for proper reveal)\n        float revealMask = 1.0 - smoothstep(revealThreshold - 0.2, revealThreshold + 0.1, distanceFromCenter);\n        \n        // Calculate sparkle brightness multiplier\n        float sparkleBrightness = sparkleNoise(vInitialPosition, uTime);\n        \n        float alpha = (1.04 - clamp(vDistance, 0.0, 1.0)) * clamp(smoothstep(-0.5, 0.25, vPosY), 0.0, 1.0) * uOpacity * revealMask * uRevealProgress * sparkleBrightness;\n\n        gl_FragColor = vec4(vec3(1.0), mix(alpha, sparkleBrightness - 1.1, uTransition));\n      }"),uniforms:{positions:{value:null},initialPositions:{value:null},uTime:{value:0},uFocus:{value:5.1},uFov:{value:50},uBlur:{value:30},uTransition:{value:0},uPointSize:{value:2},uOpacity:{value:1},uRevealFactor:{value:0},uRevealProgress:{value:0}},transparent:!0,depthWrite:!1})}}class p extends s.BKk{constructor(e=10){let n=new s.GYF(function(e,n){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:512,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,a=new Float32Array(e*n);for(let o=0;o<e;o++){let e=o*n,s=o%i/(i-1),r=Math.floor(o/i)/(i-1);a[e+0]=(s-.5)*2*t,a[e+1]=0,a[e+2]=(r-.5)*2*t,a[e+3]=1}return a}(262144,4,512,e),512,512,s.GWd,s.RQf);n.needsUpdate=!0,super({vertexShader:"varying vec2 vUv;\n      void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n      }",fragmentShader:"uniform sampler2D positions;\n      uniform float uTime;\n      uniform float uNoiseScale;\n      uniform float uNoiseIntensity;\n      uniform float uTimeScale;\n      uniform float uLoopPeriod;\n      varying vec2 vUv;\n\n      ".concat(c,"\n\n      void main() {\n        // Get the original particle position\n        vec3 originalPos = texture2D(positions, vUv).rgb;\n        \n        // Use continuous time that naturally loops through sine/cosine periodicity\n        float continuousTime = uTime * uTimeScale * (6.28318530718 / uLoopPeriod);\n        // float continuousTime = 0.0;\n        \n        // Scale position for noise input\n        vec3 noiseInput = originalPos * uNoiseScale;\n        \n        // Generate periodic displacement for each axis using different phase offsets\n        float displacementX = periodicNoise(noiseInput + vec3(0.0, 0.0, 0.0), continuousTime);\n        float displacementY = periodicNoise(noiseInput + vec3(50.0, 0.0, 0.0), continuousTime + 2.094); // +120\xb0\n        float displacementZ = periodicNoise(noiseInput + vec3(0.0, 50.0, 0.0), continuousTime + 4.188); // +240\xb0\n        \n        // Apply distortion to original position\n        vec3 distortion = vec3(displacementX, displacementY, displacementZ) * uNoiseIntensity;\n        vec3 finalPos = originalPos + distortion;\n        \n        gl_FragColor = vec4(finalPos, 1.0);\n      }"),uniforms:{positions:{value:n},uTime:{value:0},uNoiseScale:{value:1},uNoiseIntensity:{value:.5},uTimeScale:{value:1},uLoopPeriod:{value:24}}})}}var f=i(8383);function m(e){let{speed:n,aperture:i,focus:a,size:o=512,noiseScale:c=1,noiseIntensity:m=.5,timeScale:d=.5,pointSize:h=2,opacity:g=1,planeScale:x=1,useManualTime:y=!1,manualTime:k=0,introspect:b=!1,...w}=e,S=(0,r.useRef)(null),[P,T]=(0,r.useState)(!0),_=(0,r.useMemo)(()=>new p(x),[x]),z=(0,u.j)(o,o,{minFilter:s.hxR,magFilter:s.hxR,format:s.GWd,type:s.RQf}),F=(0,r.useMemo)(()=>{let e=new v;return e.uniforms.positions.value=z.texture,e.uniforms.initialPositions.value=_.uniforms.positions.value,e},[_]),[C]=(0,r.useState)(()=>new s.Z58),[j]=(0,r.useState)(()=>new s.qUd(-1,1,1,-1,1/0x20000000000000,1)),[D]=(0,r.useState)(()=>new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0])),[M]=(0,r.useState)(()=>new Float32Array([0,1,1,1,1,0,0,1,1,0,0,0])),N=(0,r.useMemo)(()=>{let e=o*o,n=new Float32Array(3*e);for(let i=0;i<e;i++){let e=3*i;n[e+0]=i%o/o,n[e+1]=i/o/o}return n},[o]);return(0,l.D)((e,t)=>{if(!F||!_)return;e.gl.setRenderTarget(z),e.gl.clear(),e.gl.render(C,j),e.gl.setRenderTarget(null);let o=y?k:e.clock.elapsedTime;null===S.current&&(S.current=o);let s=Math.min((o-S.current)/3.5,1),r=1-Math.pow(1-s,3);s>=1&&P&&T(!1),F.uniforms.uTime.value=o,F.uniforms.uFocus.value=a,F.uniforms.uBlur.value=i,f.L2(F.uniforms.uTransition,"value",+!!b,b?.35:.2,t),_.uniforms.uTime.value=o,_.uniforms.uNoiseScale.value=c,_.uniforms.uNoiseIntensity.value=m,_.uniforms.uTimeScale.value=d*n,F.uniforms.uPointSize.value=h,F.uniforms.uOpacity.value=g,F.uniforms.uRevealFactor.value=4*r,F.uniforms.uRevealProgress.value=r}),(0,t.jsxs)(t.Fragment,{children:[(0,l.o)((0,t.jsx)("mesh",{material:_,children:(0,t.jsxs)("bufferGeometry",{children:[(0,t.jsx)("bufferAttribute",{attach:"attributes-position",args:[D,3]}),(0,t.jsx)("bufferAttribute",{attach:"attributes-uv",args:[M,2]})]})}),C),(0,t.jsx)("points",{material:F,...w,children:(0,t.jsx)("bufferGeometry",{children:(0,t.jsx)("bufferAttribute",{attach:"attributes-position",args:[N,3]})})})]})}let d={uniforms:{tDiffuse:{value:null},darkness:{value:1},offset:{value:1}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    uniform sampler2D tDiffuse;\n    uniform float darkness;\n    uniform float offset;\n    varying vec2 vUv;\n    \n    void main() {\n      vec4 texel = texture2D(tDiffuse, vUv);\n      \n      // Calculate distance from center\n      vec2 uv = (vUv - 0.5) * 2.0;\n      float dist = dot(uv, uv);\n      \n      // Create vignette effect\n      float vignette = 1.0 - smoothstep(offset, offset + darkness, dist);\n      \n      gl_FragColor = vec4(texel.rgb * vignette, texel.a);\n    }\n  "},h=e=>{let{hovering:n}=e,i={speed:1,focus:3.8,aperture:1.79,size:512,noiseScale:.6,noiseIntensity:.52,timeScale:1,pointSize:10,opacity:.8,planeScale:10,vignetteDarkness:1.5,vignetteOffset:.4,useManualTime:!1,manualTime:0};return(0,t.jsx)("div",{id:"webgl",children:(0,t.jsxs)(o.Hl,{camera:{position:[1.2629783123314589,2.664606471394044,-1.8178993743288914],fov:50,near:.01,far:300},children:[(0,t.jsx)("color",{attach:"background",args:["#000"]}),(0,t.jsx)(m,{speed:i.speed,aperture:i.aperture,focus:i.focus,size:i.size,noiseScale:i.noiseScale,noiseIntensity:i.noiseIntensity,timeScale:i.timeScale,pointSize:i.pointSize,opacity:i.opacity,planeScale:i.planeScale,useManualTime:i.useManualTime,manualTime:i.manualTime,introspect:n}),(0,t.jsx)(a.d,{multisamping:0,disableGamma:!0,children:(0,t.jsx)("shaderPass",{args:[d],"uniforms-darkness-value":i.vignetteDarkness,"uniforms-offset-value":i.vignetteOffset})})]})})}},7168:(e,n,i)=>{i.d(n,{$:()=>u});var t=i(5155);i(2115);var a=i(6634),o=i(2085),s=i(3999),r=i(8668);let l=(0,o.F)("inline-flex relative uppercase border font-mono cursor-pointer items-center font-medium has-[>svg]:px-3 justify-center gap-2 whitespace-nowrap font-medium ease-out transition-all duration-300 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive [clip-path:polygon(var(--poly-roundness)_0,calc(100%_-_var(--poly-roundness))_0,100%_0,100%_calc(100%_-_var(--poly-roundness)),calc(100%_-_var(--poly-roundness))_100%,0_100%,0_calc(100%_-_var(--poly-roundness)),0_var(--poly-roundness))]",{variants:{variant:{default:"bg-background border-primary text-primary-foreground [&>[data-border]]:bg-primary [box-shadow:inset_0_0_54px_0px_var(--tw-shadow-color)] shadow-[#EBB800] hover:shadow-[#EBB800]/80"},size:{default:"h-16 px-6 text-base",sm:"h-14 px-6 text-sm"}},defaultVariants:{variant:"default",size:"default"}});function u(e){let{className:n,variant:i,size:o,children:u,asChild:c=!1,...v}=e,p=c?a.DX:"button";return(0,t.jsxs)(p,{style:{"--poly-roundness":(0,r.px)(16)},"data-slot":"button",className:(0,s.cn)(l({variant:i,size:o,className:n})),...v,children:[(0,t.jsx)("span",{"data-border":"top-left",style:{"--h":(0,r.px)(32),"--hh":(0,r.px)(6.5)},className:"absolute inline-block w-[var(--h)] top-[var(--hh)] left-[var(--hh)] h-[2px] -rotate-45 origin-top -translate-x-1/2"}),(0,t.jsx)("span",{"data-border":"bottom-right",style:{"--h":(0,r.px)(32),"--hh":(0,r.px)(6.5)},className:"absolute w-[var(--h)] bottom-[var(--hh)] right-[var(--hh)] h-[2px] -rotate-45 translate-x-1/2"}),(0,t.jsx)(a.xV,{children:u})]})}},8668:(e,n,i)=>{i.d(n,{px:()=>t});let t=e=>"".concat(e,"px")}}]);